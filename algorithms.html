<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CardioWatch 287-2B â€” Algorithm Documentation</title>
<style>
:root {
  --bg: #f5f7fa;
  --card: #ffffff;
  --accent: #1a73e8;
  --accent-light: #e8f0fe;
  --text: #202124;
  --text2: #5f6368;
  --border: #dadce0;
  --green: #0d652d;
  --green-bg: #e6f4ea;
  --orange: #e37400;
  --orange-bg: #fef7e0;
  --red: #c5221f;
  --red-bg: #fce8e6;
  --blue: #1967d2;
  --blue-bg: #e8f0fe;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; }
header { background: linear-gradient(135deg, #1a237e 0%, #1565c0 100%); color: #fff; padding: 32px 40px; }
header h1 { font-size: 28px; font-weight: 600; }
header p { color: #bbdefb; margin-top: 6px; font-size: 15px; }
.tab-bar { display: flex; flex-wrap: wrap; gap: 0; background: #fff; border-bottom: 2px solid var(--border); padding: 0 20px; position: sticky; top: 0; z-index: 100; box-shadow: 0 2px 4px rgba(0,0,0,.06); overflow-x: auto; }
.tab-btn { padding: 12px 18px; font-size: 13px; font-weight: 500; color: var(--text2); background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; white-space: nowrap; transition: all .15s; }
.tab-btn:hover { color: var(--accent); background: var(--accent-light); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); font-weight: 600; }
.tab-content { display: none; padding: 32px 40px; max-width: 1100px; margin: 0 auto; }
.tab-content.active { display: block; }
.card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 28px; margin-bottom: 24px; }
.card h2 { font-size: 22px; color: var(--accent); margin-bottom: 4px; }
.card h3 { font-size: 17px; color: var(--text); margin: 20px 0 10px; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
.card h4 { font-size: 14px; color: var(--text2); margin: 14px 0 6px; text-transform: uppercase; letter-spacing: .5px; }
.badge { display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; margin-right: 6px; }
.badge-file { background: var(--blue-bg); color: var(--blue); }
.badge-sensor { background: var(--green-bg); color: var(--green); }
.badge-rate { background: var(--orange-bg); color: var(--orange); }
.badge-plan { background: var(--red-bg); color: var(--red); }
table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 14px; }
table th { background: var(--accent-light); color: var(--accent); text-align: left; padding: 10px 14px; font-weight: 600; }
table td { padding: 9px 14px; border-bottom: 1px solid var(--border); vertical-align: top; }
table tr:last-child td { border-bottom: none; }
code { background: #f1f3f4; padding: 2px 6px; border-radius: 4px; font-size: 13px; font-family: 'Consolas', 'Fira Code', monospace; }
.pipeline { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin: 12px 0; }
.pipeline .step { background: var(--accent-light); color: var(--accent); padding: 6px 14px; border-radius: 6px; font-size: 13px; font-weight: 500; }
.pipeline .arrow { color: var(--text2); font-size: 18px; }
.plan-table td:first-child { font-weight: 600; white-space: nowrap; }
.note { background: #fffde7; border-left: 4px solid #fbc02d; padding: 12px 16px; border-radius: 0 6px 6px 0; margin: 12px 0; font-size: 14px; }
ul { padding-left: 20px; margin: 8px 0; }
li { margin: 4px 0; font-size: 14px; }
.overview-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 12px 0; }
.overview-grid .item { background: var(--bg); padding: 14px; border-radius: 8px; }
.overview-grid .item strong { display: block; color: var(--text2); font-size: 12px; text-transform: uppercase; letter-spacing: .4px; margin-bottom: 4px; }
@media(max-width:768px) {
  .tab-content { padding: 20px; }
  .overview-grid { grid-template-columns: 1fr; }
  header { padding: 20px; }
}
</style>
</head>
<body>

<header>
  <h1>CardioWatch 287-2B &mdash; Firmware Algorithm Documentation</h1>
  <p>Platform: nRF52840 (Cortex-M4F) &bull; Target: MMT287-2B_MultiColor &bull; Generated 2026-02-06 &bull; <span style="background: rgba(255,255,255,0.25); padding: 4px 12px; border-radius: 4px; font-weight: 600;">Based on FW v0.0.7.76</span></p>
</header>

<div class="tab-bar" id="tabBar">
  <button class="tab-btn active" data-tab="spo2">SpO2</button>
  <button class="tab-btn" data-tab="pulse-rate">Pulse Rate</button>
  <button class="tab-btn" data-tab="respiration">Respiration Rate</button>
  <button class="tab-btn" data-tab="nibp">Blood Pressure (NIBP)</button>
  <button class="tab-btn" data-tab="ecg">ECG Quality</button>
  <button class="tab-btn" data-tab="gait">Gait Analysis</button>
  <button class="tab-btn" data-tab="steps">Step Counter</button>
  <button class="tab-btn" data-tab="fall">Fall Detection</button>
  <button class="tab-btn" data-tab="cardiac">Cardiac Arrest</button>
  <button class="tab-btn" data-tab="wearing">Wearing Detection</button>
  <button class="tab-btn" data-tab="sleep">Sleep Staging</button>
  <button class="tab-btn" data-tab="plans">Power Plans</button>
</div>

<!-- ======================= SpO2 ======================= -->
<div class="tab-content active" id="spo2">
<div class="card">
  <h2>SpO2 &mdash; Blood Oxygen Saturation</h2>
  <p><span class="badge badge-file">mmt_vital_algorithms.c</span><span class="badge badge-file">mmt_spo2.c</span><span class="badge badge-file">mmt_process_fxi.c</span><span class="badge badge-sensor">MAX86178 PPG</span><span class="badge badge-rate">Processed every 15 s</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Raw PPG samples from Red, Infrared (and optionally Green) LEDs; LED power levels; ADC gain; sampling rate (32 or 128&nbsp;Hz). Multi-channel: RED1/IRED1 and RED2/IRED2 pairs from MAX86178.</div>
    <div class="item"><strong>Outputs</strong><code>spo2_f</code> (final fused SpO2 percentage 0&ndash;100%), quality score <code>q_f</code> (0&ndash;4), timestamp. Additionally: PPG state (<code>ppg_state_t</code>) with DC levels, LED powers, amplitudes, and pulse counts per channel.</div>
    <div class="item"><strong>Processing Cadence</strong>PPG data is accumulated per second. Every <code>SPO2_PROCESS_CHUNK_SIZE</code> = 15&nbsp;seconds (configurable, extended to 22&nbsp;s during initialization), the algorithm runs a full SpO2 calculation on each channel independently.</div>
    <div class="item"><strong>Calibration Parameters</strong><code>spo2_algorithm_params_t</code>: skin color (1&ndash;6), BMI, hair density, slope offset, SpO2 offset, DC red/IR references, quality score. Persisted in FDS at <code>FDS_MAXIM_SPO2_ALGO</code>.</div>
  </div>

  <h3>Two Implementations</h3>
  <p>The firmware contains two SpO2 processing paths:</p>
  <table>
    <tr><th>Module</th><th>File</th><th>Sampling Rate</th><th>Channels</th><th>Usage</th></tr>
    <tr><td><b>Legacy SpO2</b></td><td><code>mmt_spo2.c</code></td><td>128&nbsp;Hz (default)</td><td>Single channel (best of RED1/IRED1 or RED2/IRED2)</td><td>Standalone simpler module, older firmware path</td></tr>
    <tr><td><b>Main Vital SpO2</b></td><td><code>mmt_vital_algorithms.c</code></td><td>32 or 128&nbsp;Hz</td><td>Dual-channel with fusion &rarr; <code>spo2_f</code></td><td>Primary algorithm used in production with initialization, offset calibration, and venous pooling detection</td></tr>
  </table>

  <h3>Processing Pipeline (Main Algorithm)</h3>
  <div class="pipeline">
    <span class="step">Raw PPG (Red &amp; IR) &times;2 channels</span><span class="arrow">&rarr;</span>
    <span class="step">Band-pass Filter (4th-order Butterworth)</span><span class="arrow">&rarr;</span>
    <span class="step">Rolling Average (8-sample)</span><span class="arrow">&rarr;</span>
    <span class="step">Peak Detection (delta-based)</span><span class="arrow">&rarr;</span>
    <span class="step">SQI Assessment per channel</span><span class="arrow">&rarr;</span>
    <span class="step">Good Pulse Matching (Red+IR pairs)</span><span class="arrow">&rarr;</span>
    <span class="step">Per-pulse SpO2 with tuning</span><span class="arrow">&rarr;</span>
    <span class="step">Dual-channel Fusion &rarr; <b>spo2_f</b></span><span class="arrow">&rarr;</span>
    <span class="step">Offset + Venous Pooling</span><span class="arrow">&rarr;</span>
    <span class="step">Reporting via callback</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Band-pass Filtering</h4>
  <p>A 4th-order Butterworth band-pass filter isolates the cardiac-frequency range (~0.7&ndash;4&nbsp;Hz). Two sets of coefficients are maintained for 32&nbsp;Hz and 128&nbsp;Hz sampling rates. The filter is applied independently to the Red and Infrared channels using <code>bb_digital_float_filter()</code>. A small correction (<code>-0.000015</code>) is applied to the filter delay to compensate for C vs Python floating-point precision differences.</p>

  <h4>2. LED Normalization &amp; Deel Factor</h4>
  <p>If the IR LED power is higher than the Red LED power, raw PPG values are divided by their respective LED powers (normalization). The <code>deel</code> factor adjusts the R ratio based on IR LED power:</p>
  <ul>
    <li><code>deel = 2.0</code> if IR LED power &ge; 25</li>
    <li><code>deel = 1.8</code> otherwise</li>
  </ul>
  <p>This compensates for the calibration curve shift depending on LED drive levels.</p>

  <h4>3. Peak Detection</h4>
  <p>A delta-based peak/trough detector tracks filtered signal extrema. When the signal drops below <code>mx - delta</code>, a peak is recorded; when it rises above <code>mn + delta</code>, a trough is recorded. Peaks and inverse peaks are stored in circular <code>Peaks_array_t</code> buffers. Each peak carries: filtered value, raw PPG, LED power, timestamp, position, movement level, and amplitude.</p>

  <h4>4. Signal Quality Index (SQI)</h4>
  <p>Each pulse is evaluated against morphological criteria ported from Corsano Python code:</p>
  <ul>
    <li><b>Rise Time (RT)</b>: must be 0.08&ndash;0.49&nbsp;s</li>
    <li><b>Pulse Width Duration (PWD)</b>: must be 0.3&ndash;2.0&nbsp;s</li>
    <li><b>Amplitude symmetry</b>: left/right division &ge;&nbsp;0.4</li>
    <li><b>Systolic-Diastolic Ratio (SDR)</b>: must be &le;&nbsp;1.1</li>
    <li><b>Temporal consistency</b>: consecutive pulse ratios (PWA, RT, PWD) within 33&ndash;200%</li>
  </ul>
  <p>Both Red and IR channels are independently assessed. The count of good pulses per channel is tracked in <code>ppg_state.no_good_pulses_red</code> / <code>no_good_pulses_ired</code>.</p>

  <h4>5. Good Pulse Matching &amp; Per-pulse SpO2</h4>
  <p><code>mmt_spo2_find_good_pulses_two()</code> pairs Red and IR peaks that pass SQI. For each valid pair, a per-pulse SpO2 is computed using the linear formula:</p>
  <p><code>SpO2 = -28.6318 &times; R + 112.1152</code></p>
  <p><small>(Legacy quadratic path in <code>mmt_spo2.c</code>: <code>SpO2 = -30.089 &times; R - 0.031 &times; R&sup2; + 108.490</code>)</small></p>
  <p>Each pulse result is stored in a <code>Pulse_array_t</code> as a <code>Pulse_t</code> containing: RMS red, RMS IR, R-ratio, DC levels, SpO2 raw, SpO2 tuned (with skin/BMI offsets applied), quality flag, timestamp, and movement level. The tuned SpO2 value applies individual calibration offsets (<code>spo2_algo.spo2_offset</code>) at the pulse level.</p>

  <h4>6. SpO2 Calculation (Legacy Path &mdash; mmt_spo2.c)</h4>
  <p>The simpler single-channel path computes <code>R = RMS_red / RMS_ir / deel</code> for all good pulses, then:</p>
  <ul>
    <li>Outliers (&lt;65 or &gt;105) are rejected</li>
    <li>A 1-standard-deviation filter removes remaining outliers</li>
    <li>Final SpO2 = <b>maximum</b> of remaining values, clamped to 72&ndash;100</li>
    <li>Low SpO2 values (&lt;90) are only shown if quality &ge; 3; values &lt;97 require quality &ge; 2</li>
  </ul>

  <h4>7. SpO2f &mdash; Dual-Channel Fusion</h4>
  <p>The main algorithm (<code>mmt_vital_algorithms.c</code>) computes SpO2 independently on both optical channels (RED1/IRED1 and RED2/IRED2), producing <code>spo2_f_1</code> and <code>spo2_f_2</code>. The final <code>spo2_f</code> is derived by fusion:</p>
  <table>
    <tr><th>Scenario</th><th>Fusion Logic</th></tr>
    <tr><td>Both channels valid</td><td><code>spo2_f = (spo2_f_1 + spo2_f_2) / 2</code>, quality boosted if channels agree (&Delta; &lt; 5)</td></tr>
    <tr><td>Only Channel 1 valid</td><td><code>spo2_f = spo2_f_1</code>, quality reduced by 1</td></tr>
    <tr><td>Only Channel 2 valid</td><td><code>spo2_f = spo2_f_2</code>, quality reduced by 1</td></tr>
    <tr><td>Channels disagree &gt; 15%</td><td>Both rejected (spo2_f = 0) &mdash; only when <code>spo2_algo.rate &ge; 59</code></td></tr>
    <tr><td>One channel &ge;93, other &le;85</td><td>Low channel discarded, only high channel used (outlier rejection)</td></tr>
  </table>
  <p>The fusion is logged as <code>SPO2_F1 (val,q) SPO2_F2 (val,q)</code> and the final result as <code>SPO2_F</code>.</p>

  <h4>8. Initialization Phase</h4>
  <p>When the SpO2 module first starts (<code>mmt_spo2_initialization = true</code>), an extended initialization sequence runs for up to 7 minutes:</p>
  <ul>
    <li>First window is extended to 22&nbsp;s (15+7) instead of the normal 15&nbsp;s</li>
    <li>SpO2 values are collected into 5 sequential minute buffers (<code>spo2_1st_min_pulse_buffer</code> through <code>spo2_5th_min_pulse_buffer</code>), each holding up to 3 measurements</li>
    <li>Once at least 3 buffers have 3 samples each (or 7 minutes elapsed), the median of all buffer means is computed &rarr; <code>mid_spo2_f</code></li>
    <li>This median is used to compute the personal <code>spo2_offset</code> via <code>mmt_spo2_compute_offset()</code>, which is saved to FDS</li>
    <li>During initialization, quality is capped at 1 to avoid premature high-confidence reporting</li>
    <li>LED power optimization runs concurrently to find optimal LED levels</li>
  </ul>

  <h4>9. Quality Assignment</h4>
  <table>
    <tr><th>Quality</th><th>Condition</th></tr>
    <tr><td>0</td><td>No valid pulses or insufficient data</td></tr>
    <tr><td>1</td><td>&lt;&nbsp;3 valid pulses, or only one channel available, or during initialization</td></tr>
    <tr><td>2</td><td>R-ratio std &gt;&nbsp;0.5 (high variance between pulses)</td></tr>
    <tr><td>3</td><td>R-ratio std &gt;&nbsp;0.22 (moderate variance)</td></tr>
    <tr><td>4</td><td>All conditions met (best quality), dual-channel agreement</td></tr>
  </table>
  <p>Special quality codes at the reporting level: <code>MOTION_ALERT_CODE</code> if movement detected, <code>SPO2_LOW_QUALITY_SIGNAL</code> if no good pulses for 20+ minutes, <code>VENOUS_POLLING_CODE</code> if venous pooling detected during sleep.</p>

  <h4>10. Skin Color &amp; BMI Offset Compensation</h4>
  <table>
    <tr><th>Skin Color (Fitzpatrick)</th><th>Offset</th></tr>
    <tr><td>1 (Very light)</td><td>&minus;0.42</td></tr>
    <tr><td>2 (Light)</td><td>+1.30</td></tr>
    <tr><td>3 (Medium)</td><td>&minus;1.22</td></tr>
    <tr><td>4 (Olive)</td><td>&minus;1.40</td></tr>
    <tr><td>5&ndash;6 (Dark)</td><td>&minus;1.62</td></tr>
  </table>
  <p>BMI offset: +0.05 if BMI&lt;29; linear interpolation down to &minus;5.4 for BMI&ge;35.</p>

  <h4>11. Venous Pooling Detection</h4>
  <p>During sleep recording, SpO2 values between 60 and 92 are flagged as venous pooling (blood accumulation in extremities). These readings are set to 0 and a <code>venous_count</code> counter increments (max 30). When <code>venous_count &gt; 10</code>, the quality code is set to <code>VENOUS_POLLING_CODE</code> to inform downstream consumers.</p>

  <h4>12. Reporting &amp; Aggregation</h4>
  <p>Each computed <code>spo2_f</code> is passed to <code>mmt_spo2_callback()</code> in <code>mmt_process_fxi.c</code>, which adds it to the weighted-average buffer <code>spo2_buffer</code>. At the <code>vital_reporting_rate.Spo2</code> interval, the buffered samples are aggregated into the final activity output. Values between 90&ndash;98 are biased upward by +2, and values 80&ndash;90 by +1 before reporting.</p>

  <div class="note"><b>Reporting Rate (<code>spo2_algo.rate</code>)</b>: Controls the upstream reporting frequency (default 1800&nbsp;s = 30&nbsp;min). This is independent of the 15&nbsp;s internal processing cadence. When rate &lt; 59&nbsp;s, the <code>spo2_max</code> cap changes from 100 to 98 and additional cross-channel rejection logic is bypassed. The rate is configurable per plan via BLE command and persisted in FDS.</div>
</div>
</div>

<!-- ======================= Pulse Rate ======================= -->
<div class="tab-content" id="pulse-rate">
<div class="card">
  <h2>Pulse Rate (Heart Rate / BPM)</h2>
  <p><span class="badge badge-file">mmt_vital_algorithms.c</span><span class="badge badge-sensor">Green PPG + Accelerometer</span><span class="badge badge-rate">FFT-based, continuous</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Green PPG samples (32&nbsp;Hz); 3-axis accelerometer data (25&nbsp;Hz).</div>
    <div class="item"><strong>Outputs</strong>Heart rate (BPM), quality score, RR-interval data, RMSSD for HRV.</div>
    <div class="item"><strong>Processing Cadence</strong>FFT computed on 256-sample windows. BPM reported via callback. Adaptive BPM filter switching based on heart rate range.</div>
    <div class="item"><strong>Key Constants</strong><code>LOW_BPM_50 = 45</code>, <code>HIGH_BPM_50 = 190</code>, <code>MINIMUM_FFT_MAG = 35</code>.</div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">Green PPG (32 Hz)</span><span class="arrow">&rarr;</span>
    <span class="step">Chebyshev II Band-pass (4th order)</span><span class="arrow">&rarr;</span>
    <span class="step">Peak Detection (delta-based)</span><span class="arrow">&rarr;</span>
    <span class="step">FFT (256-pt Kiss FFT)</span><span class="arrow">&rarr;</span>
    <span class="step">Accelerometer FFT</span><span class="arrow">&rarr;</span>
    <span class="step">Motion Artifact Cancellation</span><span class="arrow">&rarr;</span>
    <span class="step">BPM Estimation</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Band-pass Filtering</h4>
  <p>The green PPG signal is filtered through a 4th-order Chebyshev Type II band-pass filter (0.7&ndash;4&nbsp;Hz passband) to isolate the cardiac component. Coefficients are adapted for different sampling rates (32, 64, 128&nbsp;Hz).</p>

  <h4>2. FFT-based BPM Extraction</h4>
  <p>A 256-point real FFT (<code>kiss_fftr</code>) is computed on the filtered green PPG data, using a dedicated internal buffer of 16&nbsp;KB (<code>fft_buffer_internal</code>). The dominant frequency peak in the 45&ndash;190&nbsp;BPM range is identified. A minimum FFT magnitude threshold of <code>MINIMUM_FFT_MAG = 35</code> rejects noise peaks. The resolution is approximately 7.5&nbsp;BPM per FFT bin at 32&nbsp;Hz sampling. Sub-bin interpolation may be applied for finer resolution.</p>

  <h4>3. Motion Artifact Cancellation</h4>
  <p>The 3-axis accelerometer magnitude is band-pass filtered (same passband) and its FFT computed. If the accelerometer shows a frequency peak within <code>ACC_FREQ_CANCELING_RANGE = 0.05 &times; 60 = 3&nbsp;BPM</code> of the PPG peak, that PPG peak is considered motion-corrupted and suppressed. This prevents step cadence from being misidentified as heart rate during walking/running.</p>

  <h4>4. Adaptive Filter Switching</h4>
  <p><code>mmt_switch_bpm_filter()</code> dynamically selects narrower or wider band-pass coefficients depending on: the currently estimated BPM, the number of consecutive good SQI pulses, RR-interval stability (<code>rr_std</code>), and peak-to-peak consistency. Multiple BPM filter coefficient sets (<code>mmt_bpm_filters.h</code>) cover different heart rate ranges. If insufficient good peaks are detected, the filter widens to capture a broader BPM range. Can be force-reinitialized when conditions change significantly.</p>

  <h4>5. RR Intervals &amp; RMSSD</h4>
  <p>RR intervals are derived from peak-to-peak timing in the green PPG, stored in a circular buffer (<code>rr_buffer</code>). The <code>calculate_RMSSD()</code> function computes the Root Mean Square of Successive Differences:</p>
  <p><code>RMSSD = sqrt(mean((RR[i+1] - RR[i])&sup2;))</code></p>
  <p>This metric feeds into: Heart Rate Variability (HRV) estimation, sleep staging data collection (written to the Corsano sleep record), and stress level evaluation.</p>

  <h4>6. BPM Weighted-Average Buffer</h4>
  <p>Each BPM reading is added with its quality score to the <code>pulse_rate_buffer</code> (weighted buffer with quality). At the <code>vital_reporting_rate.Pulse</code> interval, the aggregated weighted-average BPM is computed via <code>mmt_buffer_get_weighted_avg_value_q()</code>, with higher-quality readings having more weight. This smooths transient fluctuations. Additionally, a separate <code>hrm_buffer_high_spo2</code> stores BPM readings only when SpO2 &ge;&nbsp;95 for high-confidence BPM data.</p>

  <div class="note">BPM is reported via the <code>mmt_HR_cb</code> callback and stored with timestamp and quality for downstream consumers (sleep staging, NIBP calibration, cardiac arrest monitoring, activity file output, etc.). Default reporting rate: 60&nbsp;s. Hospital plan: 1&nbsp;s.</div>
</div>
</div>

<!-- ======================= Respiration Rate ======================= -->
<div class="tab-content" id="respiration">
<div class="card">
  <h2>Respiration Rate (BRPM)</h2>
  <p><span class="badge badge-file">mmt_vital_algorithms.c</span><span class="badge badge-sensor">Green PPG</span><span class="badge badge-rate">30&ndash;36 s window</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Green PPG signal (32&nbsp;Hz); current heart rate (for filter selection).</div>
    <div class="item"><strong>Outputs</strong>Respiration rate in breaths/min &times;&nbsp;4 (fixed-point), quality score.</div>
    <div class="item"><strong>Processing Window</strong><code>RESPIRATION_PROCESS_WINDOW</code> = 36&nbsp;s (6&nbsp;s init + 30&nbsp;s analysis). Minimum usable window: 14&nbsp;s.</div>
    <div class="item"><strong>Valid Range</strong>3&ndash;50 breaths/min (output &times;&nbsp;4 for resolution).</div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">Green PPG</span><span class="arrow">&rarr;</span>
    <span class="step">Respiration Band-pass Filter</span><span class="arrow">&rarr;</span>
    <span class="step">Peak Detection (adaptive delta)</span><span class="arrow">&rarr;</span>
    <span class="step">Breath Counting</span><span class="arrow">&rarr;</span>
    <span class="step">Rate &amp; Quality</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Adaptive Filter Selection</h4>
  <p>Three band-pass filter configurations target different respiratory ranges, automatically selected based on the current heart rate:</p>
  <table>
    <tr><th>Heart Rate</th><th>Filter</th><th>Passband (brpm)</th><th>Peak Delta Coeff</th></tr>
    <tr><td>&lt;&nbsp;55 BPM</td><td>Low</td><td>7.5&ndash;22</td><td>0.20</td></tr>
    <tr><td>55&ndash;110 BPM</td><td>Mid</td><td>10&ndash;28</td><td>0.10</td></tr>
    <tr><td>&gt;&nbsp;110 BPM</td><td>High</td><td>20&ndash;45</td><td>0.05</td></tr>
  </table>

  <h4>2. Dual-stage Filtering</h4>
  <p>Two independent filter delay lines (<code>Band_pass_filter_res_delay_green1/2</code>) are used to allow seamless reinitialization without data loss. The filter is a 4th-order Butterworth with coefficients generated from Python (<code>butter_bandpass</code>).</p>

  <h4>3. Peak Detection</h4>
  <p>A delta-based peak detector with adaptive delta: <code>delta = max(delta_min, delta_coeff &times; (max - min))</code>. This adapts to the signal amplitude to maintain robust peak detection across varying PPG conditions.</p>

  <div class="note">Respiration rate calculation uses peak-interval timing. The <code>RESP_RATE_DELTA_MAX = 320</code> guards against erroneous inter-peak intervals.</div>
</div>
</div>

<!-- ======================= NIBP ======================= -->
<div class="tab-content" id="nibp">
<div class="card">
  <h2>NIBP &mdash; Non-Invasive Blood Pressure</h2>
  <p><span class="badge badge-file">mmt_nibp.c</span><span class="badge badge-file">nibp_individual.c</span><span class="badge badge-sensor">Green PPG (128 Hz)</span><span class="badge badge-rate">Per-pulse feature extraction</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Green PPG at 128&nbsp;Hz; LED power; ADC gain; cuff calibration measurements; age; sex.</div>
    <div class="item"><strong>Outputs</strong>Systolic BP (mmHg), Diastolic BP (mmHg), quality score.</div>
    <div class="item"><strong>Valid Ranges</strong>Systolic: 60&ndash;230 mmHg. Diastolic: 40&ndash;130 mmHg.</div>
    <div class="item"><strong>Calibration</strong>Requires cuff reference measurements. Up to 10 cuff records stored in FDS. Model type switches between NBP (normal) and HBP (high BP) based on calibration.</div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">Green PPG (128 Hz)</span><span class="arrow">&rarr;</span>
    <span class="step">DC Removal + Butterworth HPF (0.54 Hz)</span><span class="arrow">&rarr;</span>
    <span class="step">Smoothing Filter</span><span class="arrow">&rarr;</span>
    <span class="step">Peak/Trough Detection</span><span class="arrow">&rarr;</span>
    <span class="step">Pulse Morphology Feature Extraction (20 features)</span><span class="arrow">&rarr;</span>
    <span class="step">SVM Regression (RBF kernel)</span><span class="arrow">&rarr;</span>
    <span class="step">Offset Correction &amp; PR Compensation</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Feature Extraction</h4>
  <p>20 morphological features are extracted from each PPG pulse:</p>
  <table>
    <tr><th>#</th><th>Feature</th><th>Description</th></tr>
    <tr><td>0</td><td>Pulse Length</td><td>Total pulse duration (normalized)</td></tr>
    <tr><td>1</td><td>Systolic Upstroke Time</td><td>Time from trough to peak</td></tr>
    <tr><td>2</td><td>Systolic Downstroke Time</td><td>Time from peak to dicrotic notch</td></tr>
    <tr><td>3&ndash;10</td><td>Width at 25/50/75/90%</td><td>Pulse width at various amplitude levels (with sub-diastolic time)</td></tr>
    <tr><td>11&ndash;12</td><td>Height at 25/50%</td><td>Signal amplitude at percentage points</td></tr>
    <tr><td>13</td><td>Height Diff</td><td>Amplitude difference metric</td></tr>
    <tr><td>14&ndash;16</td><td>Dicrotic Notch</td><td>Distance, intensity, and amplitude of dicrotic notch</td></tr>
    <tr><td>17&ndash;18</td><td>Diastolic Bump</td><td>Size and intensity of diastolic bump</td></tr>
    <tr><td>19</td><td>Pulse Count</td><td>Number of valid features</td></tr>
  </table>

  <h4>2. SVM Regression (RBF Kernel)</h4>
  <p>Separate Support Vector Regression models predict systolic and diastolic BP. Four model variants are available:</p>
  <table>
    <tr><th>Model</th><th># Support Vectors (SYS / DIAS)</th><th>Condition</th></tr>
    <tr><td>NBP</td><td>29 / 29</td><td>Normal blood pressure patients</td></tr>
    <tr><td>HBP</td><td>43 / 32</td><td>High blood pressure patients</td></tr>
    <tr><td>NBP_HAGE</td><td>29 / 20</td><td>Normal BP, age-adjusted (age &ge; 53)</td></tr>
    <tr><td>HBP_HAGE</td><td>37 / 29</td><td>High BP, age-adjusted (age &ge; 53)</td></tr>
  </table>
  <p>The RBF kernel: <code>K(x, x') = exp(-&gamma; &times; ||x - x'||&sup2;)</code> with &gamma;&nbsp;=&nbsp;1 (HBP/NBP newer models).</p>

  <h4>3. Pulse-Rate Linear Fallback</h4>
  <p>A simple linear model serves as fallback: <code>SBP = 0.6552 &times; PR + 94.47</code>, <code>DBP = 0.4153 &times; PR + 48.29</code>. The offset from this model is stored per cuff calibration.</p>

  <h4>4. Cuff Calibration</h4>
  <p>When a new cuff measurement arrives, the firmware:</p>
  <ul>
    <li>Computes the difference between predicted and measured BP</li>
    <li>Aggregates the offset with the previous offset (rolling average)</li>
    <li>Switches model to HBP if measured systolic &gt; 140&nbsp;mmHg</li>
    <li>Stores up to 10 cuff records in FDS</li>
    <li>Applies age-adjusted models (HAGE variants) when patient age &ge; 53</li>
  </ul>

  <h4>5. NIBP Measurement Scheduling</h4>
  <p>NIBP requires 128&nbsp;Hz PPG (vs. 32&nbsp;Hz for normal BPM), so it cannot run continuously in most plans. Instead, the state machine schedules 2-minute measurement windows:</p>
  <ul>
    <li>Every <code>PERIOD_MOITORING_NIBP = 30</code> minutes, if user is idle &rarr; switch to MODE_PREVENTICUS, set PPG to 128&nbsp;Hz, enable NIBP</li>
    <li>After 2 minutes of data &rarr; disable NIBP, restore normal PPG rate</li>
    <li>Reporting rate minimum: 5&nbsp;min (<code>mmt_process_fxi_set_reporting_rate_NIBP</code> enforces &ge; 300&nbsp;s)</li>
    <li>Default reporting rate: 1800&nbsp;s (30&nbsp;min). Reset to 30&nbsp;min if set to &gt; 30&nbsp;min</li>
  </ul>
  <div class="note"><b>Constraint</b>: When Emography/BioZ is enabled (<code>emography_plan != PLAN_STRESS_DISABLED</code>), 128&nbsp;Hz PPG is disabled, so NIBP operates at the lower PPG rate with reduced accuracy.</div>
</div>
</div>

<!-- ======================= ECG ======================= -->
<div class="tab-content" id="ecg">
<div class="card">
  <h2>ECG Quality Assessment</h2>
  <p><span class="badge badge-file">mmt_ECG.c</span><span class="badge badge-sensor">MAX86178 ECG</span><span class="badge badge-rate">256 Hz sampling</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Raw ECG samples (18-bit signed, 256&nbsp;Hz); ECG amplifier gain.</div>
    <div class="item"><strong>Outputs</strong>8-bit quality status code encoding: contact (1 bit), stability (1 bit), noise (2 bits), signal strength (2 bits), activity level (2 bits).</div>
    <div class="item"><strong>Windowing</strong>Small window: 40&nbsp;ms (peak-to-peak extraction). Big window: 2000&nbsp;ms (quality evaluation, ~50 small windows).</div>
    <div class="item"><strong>Conversion</strong>Raw &rarr; &micro;V: <code>ecg_uV = raw &times; (10<sup>6</sup> / 131072) / gain</code></div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">Raw ECG (18-bit)</span><span class="arrow">&rarr;</span>
    <span class="step">Sign correction &amp; &micro;V conversion</span><span class="arrow">&rarr;</span>
    <span class="step">40 ms min/max extraction</span><span class="arrow">&rarr;</span>
    <span class="step">Peak-to-peak (PP) computation</span><span class="arrow">&rarr;</span>
    <span class="step">Top-4 max &amp; Top-6 min PP tracking</span><span class="arrow">&rarr;</span>
    <span class="step">2 s quality assessment</span>
  </div>

  <h3>Quality Metrics</h3>
  <table>
    <tr><th>Metric</th><th>BAD</th><th>50/50</th><th>GOOD</th><th>EXCELLENT</th></tr>
    <tr><td><b>Stability</b> (peak ratio)</td><td>&gt;&nbsp;2.0</td><td colspan="3">&le;&nbsp;2.0</td></tr>
    <tr><td><b>Contact</b> (max PP)</td><td>&gt;&nbsp;1800 &micro;V</td><td colspan="3">&le;&nbsp;1800 &micro;V</td></tr>
    <tr><td><b>Noise</b> (min PP)</td><td>&gt;&nbsp;220</td><td>&gt;&nbsp;150</td><td>&gt;&nbsp;70</td><td>&le;&nbsp;70</td></tr>
    <tr><td><b>Strength</b> (SNR)</td><td>&lt;&nbsp;1.3</td><td>&lt;&nbsp;1.6</td><td>&lt;&nbsp;2.0</td><td>&ge;&nbsp;2.0</td></tr>
    <tr><td><b>Activity</b> (acc sum_d)</td><td>&ge;&nbsp;1500</td><td>&ge;&nbsp;800</td><td>&ge;&nbsp;400</td><td>&lt;&nbsp;400</td></tr>
  </table>

  <h4>Status Code Encoding (8 bits)</h4>
  <p><code>[Contact:1][Stability:1][Noise:2][Strength:2][Activity:2]</code></p>
  <p>A perfect ECG signal has status = <code>0b00_00_00_0_0 = 0x00</code>. The worst case is <code>0xFF</code>. The activity bits use accelerometer <code>sum_d</code> (sum of absolute differential acceleration) to estimate patient movement during ECG recording.</p>

  <h4>Plan Dependency</h4>
  <p>ECG is only available in <b>PLAN_HOSPITAL</b> (continuous 256&nbsp;Hz). In all other plans, the ECG subsystem of the MAX86178 is disabled. ECG and Emography/BioZ are mutually exclusive &mdash; starting ECG saves and disables the current stress plan, which is restored when ECG stops.</p>
</div>
</div>

<!-- ======================= Gait ======================= -->
<div class="tab-content" id="gait">
<div class="card">
  <h2>Gait Analysis</h2>
  <p><span class="badge badge-file">mmt_gait.c</span><span class="badge badge-sensor">LIS2DW12 Accelerometer</span><span class="badge badge-rate">2 s frames, 10 s integration</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>3-axis accelerometer data (32&nbsp;Hz).</div>
    <div class="item"><strong>Outputs</strong>Gait symmetry (0&ndash;99), gait speed (relative), gait variability (delta from previous).</div>
    <div class="item"><strong>Frame Size</strong>2&nbsp;s &times; 32&nbsp;Hz = 64 samples per analysis frame.</div>
    <div class="item"><strong>Integration Window</strong>5 frames (10&nbsp;s) before reporting aggregated results.</div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">3-axis ACC (32 Hz)</span><span class="arrow">&rarr;</span>
    <span class="step">Vector Magnitude</span><span class="arrow">&rarr;</span>
    <span class="step">Mean &amp; Std Deviation</span><span class="arrow">&rarr;</span>
    <span class="step">Tremor Score</span><span class="arrow">&rarr;</span>
    <span class="step">90th Percentile Scaling</span><span class="arrow">&rarr;</span>
    <span class="step">Non-linear Mapping (0&ndash;100)</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Magnitude &amp; Differential</h4>
  <p><code>magnitude = sqrt(X&sup2; + Y&sup2; + Z&sup2;)</code>. The differential acceleration <code>d_acc = magnitude[i] - magnitude[i-1]</code> provides the speed estimate.</p>

  <h4>2. Tremor / Symmetry Score</h4>
  <p>Standard deviation of magnitudes around the mean, divided by the 90th percentile (approximated as <code>max &times; 0.9</code>), scaled to 0&ndash;100. Then mapped through a non-linear function: <code>score = 0.426 &times; s + 0.239 &times; s&sup2;</code> and clamped to 0&ndash;99.</p>

  <h4>3. Aggregation</h4>
  <p>Over 10&nbsp;s (5 frames), the <b>minimum</b> symmetry score is kept (worst case). Speed is averaged only when above the <code>MINIMUM_GAIT_SPEED = 5</code> threshold. Variability is computed as the absolute change from the previous aggregation period.</p>
</div>
</div>

<!-- ======================= Steps ======================= -->
<div class="tab-content" id="steps">
<div class="card">
  <h2>Step Counter</h2>
  <p><span class="badge badge-file">mmt_steps_counter.c</span><span class="badge badge-file">mmt_motion_state.c</span><span class="badge badge-sensor">LIS2DW12 Accelerometer</span><span class="badge badge-rate">2 s frames</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>3-axis accelerometer data (32&nbsp;Hz); timestamps.</div>
    <div class="item"><strong>Outputs</strong>Number of steps per 2&nbsp;s frame; motion state (idle, walking, etc.).</div>
    <div class="item"><strong>Frame Size</strong>2&nbsp;s &times; 32&nbsp;Hz = 64 base samples + filter overlap.</div>
    <div class="item"><strong>Filter</strong>Butterworth band-pass (0.7&ndash;4&nbsp;Hz, order 2) + rolling mean of 5.</div>
  </div>

  <h3>Processing Pipeline</h3>
  <div class="pipeline">
    <span class="step">3-axis ACC</span><span class="arrow">&rarr;</span>
    <span class="step">Magnitude = &radic;(X&sup2;+Y&sup2;+Z&sup2;)</span><span class="arrow">&rarr;</span>
    <span class="step">Butterworth Band-pass</span><span class="arrow">&rarr;</span>
    <span class="step">Rolling Mean (5)</span><span class="arrow">&rarr;</span>
    <span class="step">Local Peak Detection</span><span class="arrow">&rarr;</span>
    <span class="step">Periodicity Filter</span><span class="arrow">&rarr;</span>
    <span class="step">Similarity Filter</span><span class="arrow">&rarr;</span>
    <span class="step">Variance Filter</span><span class="arrow">&rarr;</span>
    <span class="step">Motion State (SVM)</span><span class="arrow">&rarr;</span>
    <span class="step">Step Count</span>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. Preprocessing</h4>
  <p>Raw 3-axis data &rarr; vector magnitude &rarr; Butterworth IIR band-pass (0.7&ndash;4&nbsp;Hz) &rarr; rolling mean of 5 samples for smoothing.</p>

  <h4>2. Peak Detection</h4>
  <p>A local maximum search in windows of <code>PEAK_WINDOW_LENGTH = 4</code> samples. Each candidate peak is verified against its neighbors within <code>PEAK_HALF_INTERVAL</code>. Minimum peak threshold: <code>0.1 &times; 512 = 51.2</code>.</p>

  <h4>3. Triple Filtering</h4>
  <table>
    <tr><th>Filter</th><th>Purpose</th><th>Criteria</th></tr>
    <tr><td><b>Periodicity</b></td><td>Reject non-rhythmic peaks</td><td>Inter-peak distance must be 5&ndash;40 samples (~0.16&ndash;1.25&nbsp;s)</td></tr>
    <tr><td><b>Similarity</b></td><td>Left/right foot consistency</td><td>Amplitude difference between every-other-step &lt; threshold</td></tr>
    <tr><td><b>Variance</b></td><td>Signal energy between peaks</td><td>Variance must exceed threshold with temporal continuity</td></tr>
  </table>

  <h4>4. Motion State Classification</h4>
  <p>An SVM classifier (<code>mmt_motion_state_Detect()</code>) uses 6 features (filtered variance, amplitude, min, peak count, peak period, raw magnitude) to classify the 2&nbsp;s frame as <b>idle</b>, <b>walking</b>, or other states. Steps are only reported when the motion state is <b>walking</b>.</p>
</div>
</div>

<!-- ======================= Fall Detection ======================= -->
<div class="tab-content" id="fall">
<div class="card">
  <h2>Fall Detection</h2>
  <p><span class="badge badge-file">mmt_fall_detect.c</span><span class="badge badge-sensor">Accelerometer</span><span class="badge badge-rate">Event-driven, &le; 50 ms sampling</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>3-axis acceleration data with relative timestamps (&micro;s).</div>
    <div class="item"><strong>Outputs</strong><code>_FDEvent</code> structure: isFall flag, confidence (0&ndash;100), intensity, energy, power, long-lie metrics, timing.</div>
    <div class="item"><strong>Thresholds</strong>Low-G trigger: &le;&nbsp;250 mg. Impact: &ge;&nbsp;2250 mg. Long-lie window: 20&nbsp;s.</div>
    <div class="item"><strong>Architecture</strong>4-state state machine with circular buffer (210 samples).</div>
  </div>

  <h3>State Machine</h3>
  <table>
    <tr><th>State</th><th>Behavior</th><th>Transition</th></tr>
    <tr><td><b>IDLE</b></td><td>Monitor acceleration magnitude</td><td>&rarr; GETDATA when acc &le; 250 mg and sampling &le; 50&nbsp;ms</td></tr>
    <tr><td><b>GETDATA</b></td><td>Buffer 2&nbsp;s of data</td><td>&rarr; FALLDETECT after 2&nbsp;s elapsed</td></tr>
    <tr><td><b>FALLDETECT</b></td><td>Analyze buffer for impact (&ge; 2250 mg)</td><td>&rarr; LONGLIEDETECT if impact found; &rarr; IDLE otherwise</td></tr>
    <tr><td><b>LONGLIEDETECT</b></td><td>Monitor 20&nbsp;s for long-lie (300&ndash;600 mg band)</td><td>&rarr; IDLE after 20&nbsp;s with confidence estimate</td></tr>
  </table>

  <h3>Confidence Estimation</h3>
  <p>Starts at 100 and adjusts based on three independent factors:</p>
  <ul>
    <li><b>Signal Power</b>: optimal range 500k&ndash;950k (increases confidence); very low (&lt;200k) or very high (&gt;1250k) decreases confidence</li>
    <li><b>Intensity</b>: <code>(max - 2250) / 2250 &times; 100</code>. Low intensity (&lt;50) decreases confidence, high (&gt;50) increases</li>
    <li><b>Long Lie</b>: 0 out-of-range samples = +20; &ge;25 out-of-range samples = &minus;50</li>
  </ul>
  <p>Final confidence is clamped to 0&ndash;100 after each factor.</p>
</div>
</div>

<!-- ======================= Cardiac Arrest ======================= -->
<div class="tab-content" id="cardiac">
<div class="card">
  <h2>Cardiac Arrest Detection</h2>
  <p><span class="badge badge-file">mmt_cardiac_arrest.c</span><span class="badge badge-sensor">Green PPG</span><span class="badge badge-rate">Every 2 s</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Green PPG max and min values per second; LED power.</div>
    <div class="item"><strong>Outputs</strong>Cardiac state: <code>UNSPECIFIED (0)</code>, <code>NORMAL_RHYTHM (1)</code>, <code>CARDIAC_ARREST (2)</code>.</div>
    <div class="item"><strong>Detection Logic</strong>If the PPG peak-to-peak amplitude stays below an adaptive threshold for &ge;&nbsp;40 consecutive seconds, a cardiac arrest alarm is raised.</div>
    <div class="item"><strong>Recovery</strong>4 consecutive above-threshold readings end the alarm.</div>
  </div>

  <h3>Implementation Details</h3>
  <h4>1. 2-Second Aggregation</h4>
  <p>1-second PPG max/min values are combined into 2-second windows: <code>max_2s = max(max_1, max_2)</code>, <code>min_2s = min(min_1, min_2)</code>. The amplitude is <code>pp = max_2s - min_2s</code>.</p>

  <h4>2. Adaptive Threshold</h4>
  <p>The threshold is computed over ~1 hour of data: <code>threshold = mean(pp) / 5</code>, capped at 30. This adapts to the individual's typical PPG amplitude. Recalculated every ~1 hour; reset every ~24 hours.</p>

  <h4>3. Alarm Logic</h4>
  <ul>
    <li>If <code>pp &lt; threshold</code> for &ge;&nbsp;40 seconds &rarr; state = CARDIAC_ARREST</li>
    <li>If <code>pp &ge; threshold</code> for 4 consecutive readings while in CARDIAC_ARREST &rarr; state = NORMAL_RHYTHM</li>
  </ul>

  <h4>4. Safety Guards</h4>
  <ul>
    <li>Saturated PPG readings (&gt;65525 or &lt;10) are discarded</li>
    <li>Large jumps (&gt;60000 pp) are discarded</li>
    <li>Unstable readings (&gt;2000 pp) are ignored</li>
  </ul>

  <h4>5. Plan Dependency</h4>
  <p>Cardiac arrest detection requires continuous PPG monitoring (green channel). It runs in:</p>
  <ul>
    <li><b>HRM, HRM_MC plans</b>: Continuous monitoring</li>
    <li><b>TYPICAL / TYPICAL_MC plans</b>: Only during PPG measurement windows (2-min bursts)</li>
    <li><b>HOSPITAL plan</b>: Continuous monitoring</li>
    <li><b>5min plan</b>: Only during the 1&ndash;2 min on-phase of each 5-min cycle</li>
    <li><b>DISABLED / MAX_BATTERY plans</b>: Not available (no PPG)</li>
  </ul>
  <p>The algorithm resets its counters when PPG is turned off, so intermittent plans may not detect arrests occurring during the off-phase.</p>
</div>
</div>

<!-- ======================= Wearing Detection ======================= -->
<div class="tab-content" id="wearing">
<div class="card">
  <h2>Wearing Detection</h2>
  <p><span class="badge badge-file">mmt_wearing_detection_287_2b.h</span><span class="badge badge-sensor">Multi-channel PPG + Accelerometer</span><span class="badge badge-rate">Continuous</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>PPG values from green, red, and infrared channels; LED power; ADC gain; accelerometer data.</div>
    <div class="item"><strong>Outputs</strong>Wearing state: <code>NOT_WEARING (0)</code>, <code>WEARING_5050 (2)</code>, <code>WEARING (4)</code>. Also: PPG quality per channel (0&ndash;255).</div>
    <div class="item"><strong>Skin Types</strong>6 Fitzpatrick skin types (1&ndash;6) affect LED power and detection thresholds.</div>
    <div class="item"><strong>Functions</strong><code>mmt_wearing_detection_get_state()</code> (instantaneous), <code>mmt_wearing_detection_get_long_state()</code> (long-term average), <code>mmt_wearing_detection_get_min_state()</code> (minimum over time window).</div>
  </div>

  <h3>Detection Methods</h3>
  <table>
    <tr><th>Method</th><th>Description</th></tr>
    <tr><td><b>In-Air Detection</b></td><td>Monitors LED power vs. PPG value. If LED is at maximum and PPG is near zero, the device is likely in air (not on wrist).</td></tr>
    <tr><td><b>Skin Proximity (Green)</b></td><td>Green PPG max-min amplitude tracked over time. Low amplitude indicates no skin contact.</td></tr>
    <tr><td><b>Red/IR Cross-check</b></td><td>Red and infrared channels provide additional skin contact confirmation.</td></tr>
    <tr><td><b>Filtered PP Tracking</b></td><td>Filtered peak-to-peak with LED power correlation provides confidence metric.</td></tr>
    <tr><td><b>PPG Quality on LEDs</b></td><td>Optional visual feedback mode where LEDs indicate PPG signal quality.</td></tr>
  </table>
</div>
</div>

<!-- ======================= Sleep Staging ======================= -->
<div class="tab-content" id="sleep">
<div class="card">
  <h2>Sleep Staging (Corsano)</h2>
  <p><span class="badge badge-file">corsano_sleep_process.c</span><span class="badge badge-file">mmt_sleep_process.h</span><span class="badge badge-sensor">Accelerometer + Green PPG</span><span class="badge badge-rate">Per epoch (minutes)</span></p>

  <h3>Overview</h3>
  <div class="overview-grid">
    <div class="item"><strong>Inputs</strong>Mean movement (from accelerometer); heart rate (BPM); activity count; RMSSD (HRV metric from PPG).</div>
    <div class="item"><strong>Outputs</strong>16-byte <code>CorsanoSleepData_t</code> records written to flash: timestamp, sleep stage, movement, activity count, heart rate, RMSSD, CRC.</div>
    <div class="item"><strong>Record Format</strong>Preamble "OHR" + version (6) + data fields + CRC8. Record size: 16 bytes.</div>
    <div class="item"><strong>BPM Window</strong>75&nbsp;s primary; falls back to 150&nbsp;s then 375&nbsp;s if no BPM available.</div>
  </div>

  <h3>Data Collection</h3>
  <p>Each epoch, the firmware collects:</p>
  <ul>
    <li><b>Mean movement</b>: provided by the accelerometer processing chain</li>
    <li><b>Heart rate</b>: weighted average from <code>mmt_hrm_get_weighted_avg()</code> over 75&nbsp;s</li>
    <li><b>Activity count</b>: from <code>calculate_activity_count()</code></li>
    <li><b>RMSSD</b>: from <code>calculate_RMSSD()</code> (RR-interval variability)</li>
  </ul>
  <p>Data is packaged into a <code>CorsanoSleepData_t</code> struct, CRC8-verified, and written to flash for later retrieval via BLE.</p>

  <h3>BPM Fallback Windows</h3>
  <p>Heart rate for the sleep record uses a cascading window strategy:</p>
  <ul>
    <li><b>Primary</b>: weighted average over the last 75&nbsp;s from the HRM buffer</li>
    <li><b>Fallback 1</b>: if no data in 75&nbsp;s, extend to 150&nbsp;s</li>
    <li><b>Fallback 2</b>: if still no data, extend to 375&nbsp;s</li>
  </ul>
  <p>This ensures the sleep record is populated even during brief PPG dropouts.</p>

  <h3>Plan Dependency</h3>
  <p>Sleep staging data is collected whenever the device enters a sleep tracking mode:</p>
  <table>
    <tr><th>Plan</th><th>Sleep Mode</th><th>PPG Type</th></tr>
    <tr><td>TYPICAL / TYPICAL_MC</td><td>MODE_SLEEP_TRACKING</td><td>Single-color (Green only)</td></tr>
    <tr><td>HRM_MC</td><td>MODE_SLEEP_TRACKING_MULTICOLOR</td><td>Multi-color (Green + Red + IR)</td></tr>
    <tr><td>HOSPITAL / 25_HZ</td><td>MODE_PREVENTICUS_SLEEP</td><td>Continuous 128&nbsp;Hz / 25&nbsp;Hz</td></tr>
    <tr><td>5min</td><td>No dedicated sleep mode</td><td>Cycles between activity and monitoring</td></tr>
  </table>
  <p>Sleep mode is entered automatically based on configurable sleep/wake times (stored in FDS) and detected idle state. The <code>mmt_fxi_setSleepPreference()</code> function controls the transition: preference 1 = sleep, 2 = waking up.</p>

  <div class="note">The actual sleep stage classification (wake/light/deep/REM) is performed <b>server-side</b> by the Corsano cloud algorithm. The firmware only collects and logs the required feature vectors. The "OHR" preamble and version byte (6) identify the record format for the cloud parser.</div>
</div>
</div>

<!-- ======================= Power Plans ======================= -->
<div class="tab-content" id="plans">
<div class="card">
  <h2>Power Plans &mdash; Measurement Scheduling</h2>
  <p><span class="badge badge-file">mmt_state_machine.h</span><span class="badge badge-file">mmt_state_machine.c</span><span class="badge badge-file">mmt_ble_manage.c</span><span class="badge badge-file">mmt_process_fxi.c</span></p>

  <h3>Overview</h3>
  <p>The firmware supports multiple power plans that control which sensors are active, at what frequency measurements are taken, which operating modes are permitted, and how data is stored. The plan is set via BLE command and persisted in FDS. Each plan maps to one or more <b>operating modes</b> (MODE_NORMAL, MODE_HRM, MODE_PREVENTICUS, MODE_ACTIVITY, etc.) that determine the hardware configuration.</p>

  <h3>Architecture: Plan &rarr; Mode &rarr; Sensors</h3>
  <div class="pipeline">
    <span class="step">BLE Command sets Plan</span><span class="arrow">&rarr;</span>
    <span class="step">Plan persisted in FDS</span><span class="arrow">&rarr;</span>
    <span class="step">MMT_TASK_VERIFY_PLAN_SET_MODE</span><span class="arrow">&rarr;</span>
    <span class="step">Operating Mode selected</span><span class="arrow">&rarr;</span>
    <span class="step">Sensors &amp; Vitals configured</span>
  </div>

  <h3>Plan Definitions</h3>
  <table class="plan-table">
    <tr><th>Plan ID</th><th>Name</th><th>Default Mode</th><th>Description</th></tr>
    <tr><td>0</td><td>PLAN_DISABLED</td><td>MODE_SLEEP</td><td>All measurements off. Minimum power consumption. Only accelerometer-based step counting may remain on.</td></tr>
    <tr><td>1</td><td>PLAN_MAX_BATTERY</td><td>MODE_ACTIVITY</td><td>Maximum battery life. Only accelerometer processing (steps, gait, fall detection). No PPG, no vitals. Activity file at configurable resolution (default 60&nbsp;s).</td></tr>
    <tr><td>2</td><td>PLAN_TYPICAL</td><td>MODE_NORMAL</td><td>Balanced mode. Single-color (Green) PPG at 32&nbsp;Hz. Heart rate every 1&nbsp;min, 2-min measurement bursts every 30&nbsp;min for SpO2/NIBP/Resp when reporting rates are configured. Sleep tracking at night.</td></tr>
    <tr><td>3</td><td>PLAN_HRM</td><td>MODE_HRM</td><td>Continuous heart rate monitoring with single-color PPG. Higher BPM accuracy. Periodic 2-min multicolor bursts every 30&nbsp;min when NIBP/SpO2 rates are set.</td></tr>
    <tr><td>4</td><td>PLAN_25_HZ</td><td>MODE_NORMAL</td><td>PPG at 25&nbsp;Hz sampling rate. Same schedule as TYPICAL but with reduced PPG bandwidth. Goes to PREVENTICUS_SLEEP at night.</td></tr>
    <tr><td>5</td><td>PLAN_HOSPITAL</td><td>MODE_PREVENTICUS</td><td>Highest fidelity. Continuous 128&nbsp;Hz PPG (Red+IR+Green). All vitals continuous. ECG enabled. Night mode: PREVENTICUS_SLEEP. Used in clinical settings.</td></tr>
    <tr><td>7</td><td>PLAN_TYPICAL_MULTICOLOR</td><td>MODE_NORMAL</td><td>Balanced mode with multi-wavelength PPG (Red + IR + Green). Enables SpO2 during 2-min measurement windows. Sleep tracking with multicolor at night.</td></tr>
    <tr><td>8</td><td>PLAN_HRM_MULTICOLOR</td><td>MODE_HRM_MULTICOLOR</td><td>Continuous HR + SpO2 with multi-wavelength PPG. Periodic 2-min 128&nbsp;Hz bursts for NIBP every 30&nbsp;min. Sleep tracking multicolor at night.</td></tr>
    <tr><td>9</td><td>PLAN_INTERMITTENT_MC_RAW</td><td>MODE_HRM</td><td>Intermittent multi-color measurements with raw data logging (PPG files). 2-min bursts every 30&nbsp;min with raw PPG export.</td></tr>
    <tr><td>10</td><td>PLAN_INTERMITTENT_MC</td><td>MODE_HRM</td><td>Intermittent multi-color measurements (processed data only, no raw PPG). 2-min bursts every 30&nbsp;min.</td></tr>
    <tr><td>11</td><td>PLAN_5min</td><td>MODE_HRM_MULTICOLOR</td><td>Alternates: ~1&ndash;2&nbsp;min multicolor monitoring every 5 minutes, then switches to MODE_ACTIVITY. NIBP burst every 30&nbsp;min at 128&nbsp;Hz. LED optimization on first run.</td></tr>
  </table>

  <h3>Vital Parameter Reporting Rates</h3>
  <p>Each vital parameter has an independent configurable reporting rate (<code>vital_reporting_rate</code> struct in <code>mmt_process_fxi.c</code>), set in <b>seconds</b>. The rate controls how often the aggregated/weighted-average value is written to the activity file. The internal processing cadence is always faster (e.g., SpO2 processes every 15&nbsp;s, BPM is continuous).</p>

  <table>
    <tr><th>Vital Parameter</th><th>Field</th><th>Default Value</th><th>Min Allowed</th><th>Typical Values per Plan</th></tr>
    <tr><td><b>Heart Rate (BPM)</b></td><td><code>vital_reporting_rate.Pulse</code></td><td>60&nbsp;s (1&nbsp;min)</td><td>1&nbsp;s</td><td>HOSPITAL: 1&nbsp;s &bull; HRM/HRM_MC: 1&nbsp;s &bull; TYPICAL: 60&nbsp;s &bull; 5min: 60&nbsp;s</td></tr>
    <tr><td><b>SpO2</b></td><td><code>vital_reporting_rate.Spo2</code></td><td>1800&nbsp;s (30&nbsp;min)</td><td>30&nbsp;s</td><td>HOSPITAL: 30&nbsp;s &bull; HRM_MC: 60&nbsp;s &bull; TYPICAL_MC: 1800&nbsp;s &bull; 5min: 300&nbsp;s</td></tr>
    <tr><td><b>Respiration Rate</b></td><td><code>vital_reporting_rate.Resp</code></td><td>1800&nbsp;s (30&nbsp;min)</td><td>&mdash;</td><td>HOSPITAL: 30&nbsp;s &bull; HRM_MC: 30&nbsp;s &bull; TYPICAL: 1800&nbsp;s</td></tr>
    <tr><td><b>Activity</b></td><td><code>vital_reporting_rate.Act</code></td><td>60&nbsp;s (1&nbsp;min)</td><td>&mdash;</td><td>HOSPITAL: 60&nbsp;s &bull; All others: 60&nbsp;s</td></tr>
    <tr><td><b>Temperature</b></td><td><code>vital_reporting_rate.Temp</code></td><td>60&nbsp;s (1&nbsp;min)</td><td>&mdash;</td><td>HOSPITAL: 60&nbsp;s &bull; All others: 60&nbsp;s</td></tr>
    <tr><td><b>NIBP (Blood Pressure)</b></td><td><code>vital_reporting_rate.NIBP</code></td><td>1800&nbsp;s (30&nbsp;min)</td><td>300&nbsp;s (5&nbsp;min)</td><td>HOSPITAL: 300&nbsp;s &bull; HRM_MC: 1800&nbsp;s &bull; 5min: 1800&nbsp;s</td></tr>
  </table>
  <div class="note">These rates are configurable via BLE command (opcode in <code>mmt_ble_manage.c</code>, vitals 1&ndash;6) and persisted in FDS at <code>MMT_TASK_PERSIST_VITALS_RATES_IN_FDS</code>. When the SpO2 rate changes, <code>mmt_vital_spo2_set_rate()</code> is called to update the internal <code>spo2_algo.rate</code>.</div>

  <h3>Plan Impact on Algorithms</h3>
  <table>
    <tr><th>Algorithm</th><th>DISABLED</th><th>MAX_BATTERY</th><th>TYPICAL / TYPICAL_MC</th><th>HRM / HRM_MC</th><th>HOSPITAL</th><th>5min</th></tr>
    <tr><td><b>Heart Rate</b></td><td>Off</td><td>Off</td><td>1/min (2-min bursts every 30&nbsp;min)</td><td>Continuous</td><td>Continuous (1&nbsp;s reporting)</td><td>~1&ndash;2&nbsp;min on / 3&ndash;4&nbsp;min off cycle</td></tr>
    <tr><td><b>SpO2</b></td><td>Off</td><td>Off</td><td>Off (single-color) or 1/30min (multicolor)</td><td>Continuous (1/min MC)</td><td>Continuous (1/30s)</td><td>~1/5min (during on-phase)</td></tr>
    <tr><td><b>NIBP</b></td><td>Off</td><td>Off</td><td>2-min burst every 30&nbsp;min at 128&nbsp;Hz</td><td>2-min burst every 30&nbsp;min at 128&nbsp;Hz</td><td>Continuous 128&nbsp;Hz</td><td>2-min burst every 30&nbsp;min at 128&nbsp;Hz</td></tr>
    <tr><td><b>ECG</b></td><td>Off</td><td>Off</td><td>Off</td><td>Off</td><td>On (256&nbsp;Hz)</td><td>Off</td></tr>
    <tr><td><b>Resp. Rate</b></td><td>Off</td><td>Off</td><td>1/30min (during PPG bursts)</td><td>Continuous</td><td>Continuous</td><td>During on-phase</td></tr>
    <tr><td><b>Steps / Gait</b></td><td>Off</td><td>Always on</td><td>Always on</td><td>Always on</td><td>Always on</td><td>Always on</td></tr>
    <tr><td><b>Fall Detect</b></td><td>Off</td><td>Always on</td><td>Always on</td><td>Always on</td><td>Always on</td><td>Always on</td></tr>
    <tr><td><b>Cardiac Arrest</b></td><td>Off</td><td>Off</td><td>During PPG bursts</td><td>Continuous</td><td>Continuous</td><td>During on-phase</td></tr>
    <tr><td><b>Sleep Staging</b></td><td>Off</td><td>Off</td><td>At night (MODE_SLEEP_TRACKING)</td><td>At night</td><td>At night (PREVENTICUS_SLEEP)</td><td>Off</td></tr>
    <tr><td><b>PPG Sampling</b></td><td>Off</td><td>Off</td><td>32&nbsp;Hz green / 128&nbsp;Hz during 2-min bursts</td><td>32&nbsp;Hz green / 128&nbsp;Hz bursts</td><td>128&nbsp;Hz continuous (R+IR+G)</td><td>32&nbsp;Hz green / 128&nbsp;Hz NIBP bursts</td></tr>
    <tr><td><b>Wearing Detection</b></td><td>Off</td><td>Off</td><td>During PPG on</td><td>Continuous</td><td>Continuous</td><td>During on-phase</td></tr>
  </table>

  <h3>The 2-min / 30-min Measurement Pattern</h3>
  <p>Many plans use an intermittent pattern (<code>mmt_state_30min_2min_measurements()</code>) where the device alternates between a low-power base mode and a 2-minute high-fidelity measurement window:</p>
  <ul>
    <li>Every <b>30 minutes</b> (<code>PERIOD_MOITORING_NIBP = 30</code>), the state machine checks if the user is idle enough (activity &le; IDLE_5050)</li>
    <li>If idle: switch to MODE_PREVENTICUS, enable 128&nbsp;Hz PPG, enable NIBP monitoring for 2 minutes</li>
    <li>If too active: schedule a retry (<code>mmt_retrial_Res_spo2_enabled</code>) that retries every minute, forcing measurement in the last 1/3 of the 30-min period</li>
    <li>After 2 minutes: switch back to the base PPG rate, disable NIBP monitoring</li>
  </ul>
  <p>This applies to: <b>TYPICAL</b>, <b>TYPICAL_MC</b>, <b>HRM</b>, <b>HRM_MC</b>, <b>INTERMITTENT_MC</b>, and <b>5min</b> plans.</p>

  <h3>PLAN_5min Detail &mdash; Activity/Monitoring Cycle</h3>
  <p>The 5-minute plan uses a unique cycling strategy between MODE_ACTIVITY (accelerometer only, low power) and MODE_HRM_MULTICOLOR (full vital monitoring):</p>
  <table>
    <tr><th>Phase</th><th>Duration</th><th>Mode</th><th>What Runs</th></tr>
    <tr><td>Monitoring</td><td>~1&ndash;2 min (until vitals are good, max 10&nbsp;min)</td><td>MODE_HRM_MULTICOLOR</td><td>Green PPG 32&nbsp;Hz, Red/IR PPG, BPM, SpO2, Resp Rate, Cardiac Arrest detection</td></tr>
    <tr><td>Activity</td><td>~3&ndash;4 min (until next 5-min boundary)</td><td>MODE_ACTIVITY</td><td>Accelerometer only: steps, gait, fall detection. Minimal power.</td></tr>
    <tr><td>NIBP burst</td><td>2 min every 30 min</td><td>MODE_PREVENTICUS</td><td>128&nbsp;Hz PPG, NIBP feature extraction, BP prediction</td></tr>
  </table>
  <p>The switch from monitoring to activity happens when <code>mmt_process_fxi_are_vitals_good(2min)</code> returns true (SpO2 &ge; 90, quality &ge; 1, at least 2 samples) or after 10 minutes timeout. LED optimization delays the first switch if LEDs were recently optimized.</p>

  <h3>SpO2 Internal Rate Parameter (<code>spo2_algo.rate</code>)</h3>
  <p>In addition to the reporting rate, SpO2 has an internal rate parameter that affects the algorithm behavior:</p>
  <table>
    <tr><th>Rate Value (seconds)</th><th>Effective Frequency</th><th>Behavioral Changes</th><th>Typical Plan</th></tr>
    <tr><td>1800 (default)</td><td>Every 30 minutes</td><td>Standard mode. Cross-channel rejection active. <code>spo2_max = 100</code>.</td><td>TYPICAL_MULTICOLOR</td></tr>
    <tr><td>300</td><td>Every 5 minutes</td><td>Cross-channel rejection active. <code>spo2_max = 100</code>.</td><td>PLAN_5min</td></tr>
    <tr><td>60</td><td>Every 1 minute</td><td>Cross-channel rejection active (rate &ge; 59). <code>spo2_max = 100</code>.</td><td>HRM_MULTICOLOR</td></tr>
    <tr><td>30</td><td>Every 30 seconds</td><td>High-frequency mode. Cross-channel rejection bypassed (rate &lt; 59). <code>spo2_max = 98</code>. Faster responsiveness.</td><td>HOSPITAL</td></tr>
  </table>
  <p>When <code>rate &ge; 59</code>: if both channels produce SpO2 but differ by &ge;15%, both are rejected. If one channel reports &ge;93 and the other &le;85, the low channel is discarded.<br>
  When <code>rate &lt; 59</code>: these cross-channel safety checks are bypassed for faster updates (HOSPITAL plan).</p>

  <h3>Stress / BioZ Plans</h3>
  <p>A secondary plan system controls Emography (stress measurement) and raw BioZ recording, independent of the main vital plan:</p>
  <table>
    <tr><th>Plan ID</th><th>Name</th><th>Description</th><th>Impact</th></tr>
    <tr><td>1</td><td>PLAN_STRESS_DISABLED</td><td>Emography / BioZ measurements disabled.</td><td>No effect on PPG. 128&nbsp;Hz PPG available during NIBP bursts.</td></tr>
    <tr><td>2</td><td>PLAN_STRESS_NIGHT</td><td>BioZ measurements enabled only during nighttime (sleep).</td><td>PPG forced to 32&nbsp;Hz when BioZ active (cannot run 128&nbsp;Hz PPG + BioZ simultaneously).</td></tr>
    <tr><td>3</td><td>PLAN_STRESS_ALWAYS</td><td>BioZ measurements always enabled.</td><td>PPG always at 32&nbsp;Hz. NIBP 128&nbsp;Hz bursts disabled. Raw BioZ data written to file.</td></tr>
  </table>
  <div class="note"><b>Constraint</b>: Emography/BioZ and 128&nbsp;Hz PPG are mutually exclusive on the MAX86178. When emography is enabled, the firmware forces <code>MAX86178_set_high_freq_sampling_rate(false)</code> and NIBP measurements use the lower PPG rate.</div>

  <h3>Vital States System</h3>
  <p>Each vital parameter has an independent state machine (<code>mmt_vital_state_t</code>) with configurable enable/disable, rate, and processing time:</p>
  <table>
    <tr><th>Vital ID</th><th>Name</th><th>Processing Time (s)</th><th>Minimum Period (s)</th><th>Default Rate (s)</th></tr>
    <tr><td>V_BPM (0)</td><td>Heart Rate</td><td>4</td><td>10</td><td>60</td></tr>
    <tr><td>V_TEMP (1)</td><td>Temperature</td><td>14</td><td>14</td><td>60</td></tr>
    <tr><td>V_NIBP (2)</td><td>Blood Pressure</td><td>28</td><td>112</td><td>1800</td></tr>
    <tr><td>V_BRPM (3)</td><td>Respiration Rate</td><td>14</td><td>112</td><td>1800</td></tr>
    <tr><td>V_SPO2 (4)</td><td>SpO2</td><td>1</td><td>10</td><td>60</td></tr>
    <tr><td>V_RR (5)</td><td>RR Intervals</td><td>1</td><td>1</td><td>0 (off)</td></tr>
    <tr><td>V_SLEEP (6)</td><td>Sleep</td><td>30</td><td>300</td><td>0 (off)</td></tr>
    <tr><td>V_AFIB (7)</td><td>AFib</td><td>30</td><td>150</td><td>0 (off)</td></tr>
    <tr><td>V_SPO2 (8)</td><td>SpO2 (2nd)</td><td>120</td><td>120</td><td>1800</td></tr>
  </table>
  <p>The state machine checks every 10&nbsp;s whether each vital's rate period has elapsed, then toggles the start/stop of the corresponding sensor. Processing times define how long the sensor must run before producing a valid measurement.</p>

  <div class="note">The plan is set via BLE command (opcode in <code>mmt_ble_manage.c</code>) and persisted in FDS at keys <code>FDS_PLAN_FILE_ID / FDS_PLAN_CONFIG_ID</code>. Changing the plan triggers <code>MMT_TASK_VERIFY_PLAN_SET_MODE</code> which validates the current mode is compatible with the new plan and reconfigures all sensor subsystems accordingly. If incompatible, the firmware automatically switches to the correct default mode for the new plan.</div>
</div>
</div>

<script>
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});
</script>
</body>
</html>
